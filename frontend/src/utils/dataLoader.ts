import { TrainingExample } from '@/types';

/**
 * Data loading utilities for Turkish verb training examples
 * Uses the navigation index generated by Python script to ensure reliable file paths
 */

interface NavigationIndex {
  verbs: string[];
  verb_data: Record<string, {
    english_name: string;
    turkish_infinitive: string;
    folder_name: string;
    tenses: Record<string, {
      pronouns: string[];
      files: Array<{
        pronoun: string;
        file_path: string;
        relative_path: string;
      }>;
    }>;
    files: Array<{
      pronoun: string;
      tense: string;
      infinitive: string;
      file_path: string;
      relative_path: string;
      rank: number;
    }>;
  }>;
}

class DataLoader {
  private cache = new Map<string, TrainingExample>();
  private navigationIndex: NavigationIndex | null = null;

  /**
   * Load navigation index from the JSON file generated by Python script
   */
  async loadNavigationIndex(): Promise<NavigationIndex> {
    if (this.navigationIndex) {
      return this.navigationIndex;
    }

    try {
      console.log('Loading navigation index...');
      const response = await fetch('/data/navigation_index.json');
      if (!response.ok) {
        throw new Error(`Failed to load navigation index: ${response.status} ${response.statusText}`);
      }
      
      this.navigationIndex = await response.json();
      console.log('Navigation index loaded successfully:', {
        totalVerbs: this.navigationIndex!.verbs.length,
        verbSample: this.navigationIndex!.verbs.slice(0, 3)
      });
      
      return this.navigationIndex!;
    } catch (error) {
      console.error('Error loading navigation index:', error);
      throw new Error('Failed to load navigation data. Please ensure the navigation index has been generated.');
    }
  }

  /**
   * Load a training example using exact file path from navigation index
   * If requested pronoun/tense isn't available, falls back to first available combination
   */
  async loadTrainingExample(
    verbEnglish: string, 
    pronoun: string, 
    tense: string
  ): Promise<TrainingExample | null> {
    try {
      // Load navigation index if not already loaded
      const navIndex = await this.loadNavigationIndex();
      
      // Find verb data
      const verbData = navIndex.verb_data[verbEnglish];
      if (!verbData) {
        console.warn(`Verb "${verbEnglish}" not found in navigation index`);
        return null;
      }

      // If no files available at all, return null
      if (!verbData.files || verbData.files.length === 0) {
        console.warn(`No training examples available for verb "${verbEnglish}"`);
        return null;
      }

      let fileInfo = null;
      let actualTense = tense;
      let actualPronoun = pronoun;

      // Try to find exact match first
      const tenseData = verbData.tenses[tense];
      if (tenseData) {
        fileInfo = tenseData.files.find(f => f.pronoun === pronoun);
        if (fileInfo) {
          console.log(`✓ Exact match found: ${verbEnglish} - ${tense} (${pronoun})`);
        }
      }

      // If no exact match, try to find same tense but different pronoun
      if (!fileInfo && tenseData && tenseData.files.length > 0) {
        fileInfo = tenseData.files[0];
        actualPronoun = fileInfo.pronoun;
        console.log(`⚠ Pronoun "${pronoun}" not available, using first available: "${actualPronoun}"`);
      }

      // If still no match, try to find same pronoun but different tense
      if (!fileInfo) {
        for (const [tName, tData] of Object.entries(verbData.tenses)) {
          const match = tData.files.find(f => f.pronoun === pronoun);
          if (match) {
            fileInfo = match;
            actualTense = tName;
            actualPronoun = pronoun;
            console.log(`⚠ Tense "${tense}" not available, using first available: "${actualTense}"`);
            break;
          }
        }
      }

      // If still no match, just use the first available file for this verb
      if (!fileInfo && verbData.files.length > 0) {
        const firstFile = verbData.files[0];
        actualTense = firstFile.tense;
        actualPronoun = firstFile.pronoun;
        // Find the fileInfo from tenses structure
        const firstTenseData = verbData.tenses[actualTense];
        if (firstTenseData) {
          fileInfo = firstTenseData.files.find(f => f.pronoun === actualPronoun);
        }
        console.log(`⚠ Requested combination not available, using first available: ${actualTense} (${actualPronoun})`);
      }

      if (!fileInfo) {
        console.warn(`No file info found for verb "${verbEnglish}"`);
        return null;
      }

      // Create cache key with actual values
      const cacheKey = `${verbEnglish}-${actualPronoun}-${actualTense}`;
      
      if (this.cache.has(cacheKey)) {
        console.log(`Cache hit for: ${cacheKey}`);
        return this.cache.get(cacheKey)!;
      }

      const filePath = `/${fileInfo.file_path}`;
      console.log(`Loading from path: ${filePath}`);
      
      try {
        const response = await fetch(filePath);
        if (!response.ok) {
          console.warn(`Failed to load: ${filePath} (${response.status}: ${response.statusText})`);
          return null;
        }

        const data: TrainingExample = await response.json();
        
        // Validate that we have the required data
        if (!data.turkish_verb || !data.verb_english) {
          console.warn(`Invalid training example data in ${filePath}`);
          return null;
        }
        
        console.log(`✅ Successfully loaded: ${data.verb_english} - ${data.turkish_verb.verb_tense} (${actualPronoun})`);
        
        // Cache the result
        this.cache.set(cacheKey, data);
        
        return data;
        
      } catch (fetchError) {
        console.warn(`Network error loading ${filePath}:`, fetchError);
        return null;
      }
    } catch (error) {
      console.error('Error loading training example:', error);
      return null;
    }
  }

  /**
   * Get all available verbs from navigation index
   */
  async getAvailableVerbs(): Promise<string[]> {
    const navIndex = await this.loadNavigationIndex();
    console.log('Available verbs from navigation index:', navIndex.verbs);
    return navIndex.verbs;
  }

  /**
   * Get all available verbs with their ranks
   * Extracts actual verb_rank from training example files in navigation index
   */
  async getVerbsWithRanks(): Promise<Array<{ verb: string; rank: number }>> {
    const navIndex = await this.loadNavigationIndex();
    const verbRanks = new Map<string, number>();
    
    // Extract verb ranks from navigation index files
    // Use the first valid (non-zero, non-null) rank found for each verb
    for (const [verbEnglish, verbData] of Object.entries(navIndex.verb_data)) {
      const ranks = verbData.files
        .map(f => f.rank)
        .filter(r => r && r > 0); // Filter out null, undefined, and 0
      
      if (ranks.length > 0) {
        // Use the minimum rank (most common)
        const minRank = Math.min(...ranks);
        verbRanks.set(verbEnglish, minRank);
      }
    }
    
    // Convert to array and sort by rank
    const verbsWithRanks = Array.from(verbRanks.entries())
      .map(([verb, rank]) => ({ verb, rank }))
      .sort((a, b) => a.rank - b.rank);
    
    console.log('Verbs with ranks (sorted by rank):', verbsWithRanks.slice(0, 5));
    
    return verbsWithRanks;
  }

  /**
   * Get available tenses for a specific verb
   */
  async getAvailableTenses(verbEnglish: string): Promise<string[]> {
    const navIndex = await this.loadNavigationIndex();
    const verbData = navIndex.verb_data[verbEnglish];
    
    if (!verbData) {
      console.warn(`Verb "${verbEnglish}" not found in navigation index`);
      return [];
    }
    
    const tenses = Object.keys(verbData.tenses);
    console.log(`Available tenses for "${verbEnglish}":`, tenses);
    return tenses;
  }

  /**
   * Get available pronouns for a specific verb and tense
   */
  async getAvailablePronouns(verbEnglish: string, tense: string): Promise<string[]> {
    const navIndex = await this.loadNavigationIndex();
    const verbData = navIndex.verb_data[verbEnglish];
    
    if (!verbData) {
      console.warn(`Verb "${verbEnglish}" not found in navigation index`);
      return [];
    }
    
    const tenseData = verbData.tenses[tense];
    if (!tenseData) {
      console.warn(`Tense "${tense}" not found for verb "${verbEnglish}"`);
      return [];
    }
    
    console.log(`Available pronouns for "${verbEnglish}" in "${tense}":`, tenseData.pronouns);
    return tenseData.pronouns;
  }



  /**
   * Get next verb in sequence
   */
  async getNextVerb(currentVerb: string): Promise<string | null> {
    const availableVerbs = await this.getAvailableVerbs();
    const currentIndex = availableVerbs.indexOf(currentVerb);
    
    if (currentIndex === -1) {
      console.log('Current verb not found, returning first verb:', availableVerbs[0]);
      return availableVerbs[0]; // Return first verb if current not found
    }
    
    if (currentIndex >= availableVerbs.length - 1) {
      console.log('At end of list, looping back to first verb:', availableVerbs[0]);
      return availableVerbs[0]; // Loop back to first verb
    }
    
    const nextVerb = availableVerbs[currentIndex + 1];
    console.log('Next verb:', nextVerb);
    return nextVerb;
  }

  /**
   * Get previous verb in sequence
   */
  async getPrevVerb(currentVerb: string): Promise<string | null> {
    const availableVerbs = await this.getAvailableVerbs();
    const currentIndex = availableVerbs.indexOf(currentVerb);
    
    if (currentIndex === -1) {
      console.log('Current verb not found, returning last verb:', availableVerbs[availableVerbs.length - 1]);
      return availableVerbs[availableVerbs.length - 1];
    }
    
    if (currentIndex <= 0) {
      console.log('At beginning of list, looping back to last verb:', availableVerbs[availableVerbs.length - 1]);
      return availableVerbs[availableVerbs.length - 1];
    }
    
    const prevVerb = availableVerbs[currentIndex - 1];
    console.log('Previous verb:', prevVerb);
    return prevVerb;
  }

  /**
   * Get next tense for current verb
   */
  async getNextTense(verbEnglish: string, currentTense: string): Promise<string | null> {
    const tenses = await this.getAvailableTenses(verbEnglish);
    const currentIndex = tenses.indexOf(currentTense);
    
    if (currentIndex === -1) {
      console.log(`Tense "${currentTense}" not found, returning first tense:`, tenses[0]);
      return tenses[0]; // Return first tense if current not found
    }
    
    if (currentIndex >= tenses.length - 1) {
      console.log('At end of tense list, looping back to first tense:', tenses[0]);
      return tenses[0]; // Loop back to first tense
    }
    
    const nextTense = tenses[currentIndex + 1];
    console.log('Next tense:', nextTense);
    return nextTense;
  }

  /**
   * Get previous tense for current verb
   */
  async getPrevTense(verbEnglish: string, currentTense: string): Promise<string | null> {
    const tenses = await this.getAvailableTenses(verbEnglish);
    const currentIndex = tenses.indexOf(currentTense);
    
    if (currentIndex === -1) {
      console.log(`Tense "${currentTense}" not found, returning last tense:`, tenses[tenses.length - 1]);
      return tenses[tenses.length - 1];
    }
    
    if (currentIndex <= 0) {
      console.log('At beginning of tense list, looping back to last tense:', tenses[tenses.length - 1]);
      return tenses[tenses.length - 1];
    }
    
    const prevTense = tenses[currentIndex - 1];
    console.log('Previous tense:', prevTense);
    return prevTense;
  }

  /**
   * Get next pronoun for current verb/tense
   */
  async getNextPronoun(verbEnglish: string, tense: string, currentPronoun: string): Promise<string | null> {
    const pronouns = await this.getAvailablePronouns(verbEnglish, tense);
    const currentIndex = pronouns.indexOf(currentPronoun);
    
    if (currentIndex === -1) {
      console.log(`Pronoun "${currentPronoun}" not found, returning first pronoun:`, pronouns[0]);
      return pronouns[0]; // Return first pronoun if current not found
    }
    
    if (currentIndex >= pronouns.length - 1) {
      console.log('At end of pronoun list, looping back to first pronoun:', pronouns[0]);
      return pronouns[0]; // Loop back to first pronoun
    }
    
    const nextPronoun = pronouns[currentIndex + 1];
    console.log('Next pronoun:', nextPronoun);
    return nextPronoun;
  }

  /**
   * Get previous pronoun for current verb/tense
   */
  async getPrevPronoun(verbEnglish: string, tense: string, currentPronoun: string): Promise<string | null> {
    const pronouns = await this.getAvailablePronouns(verbEnglish, tense);
    const currentIndex = pronouns.indexOf(currentPronoun);
    
    if (currentIndex === -1) {
      console.log(`Pronoun "${currentPronoun}" not found, returning last pronoun:`, pronouns[pronouns.length - 1]);
      return pronouns[pronouns.length - 1];
    }
    
    if (currentIndex <= 0) {
      console.log('At beginning of pronoun list, looping back to last pronoun:', pronouns[pronouns.length - 1]);
      return pronouns[pronouns.length - 1];
    }
    
    const prevPronoun = pronouns[currentIndex - 1];
    console.log('Previous pronoun:', prevPronoun);
    return prevPronoun;
  }

  /**
   * Get verb by index (for rank-like functionality)
   */
  async getVerbByIndex(index: number): Promise<string | null> {
    const availableVerbs = await this.getAvailableVerbs();
    if (index >= 0 && index < availableVerbs.length) {
      return availableVerbs[index];
    }
    return null;
  }

  /**
   * Get random training example for quick start
   */
  async getRandomExample(): Promise<TrainingExample | null> {
    try {
      const verbs = await this.getAvailableVerbs();
      if (verbs.length === 0) return null;
      
      const randomVerb = verbs[Math.floor(Math.random() * verbs.length)];
      const tenses = await this.getAvailableTenses(randomVerb);
      if (tenses.length === 0) return null;
      
      const randomTense = tenses[Math.floor(Math.random() * tenses.length)];
      const pronouns = await this.getAvailablePronouns(randomVerb, randomTense);
      if (pronouns.length === 0) return null;
      
      const randomPronoun = pronouns[Math.floor(Math.random() * pronouns.length)];
      
      return await this.loadTrainingExample(randomVerb, randomPronoun, randomTense);
    } catch (error) {
      console.error('Error getting random example:', error);
      return null;
    }
  }

  /**
   * Get summary statistics from navigation index
   */
  async getStatistics(): Promise<{
    totalVerbs: number;
    verbsWithData: string[];
    totalFiles: number;
  }> {
    const navIndex = await this.loadNavigationIndex();
    const totalFiles = Object.values(navIndex.verb_data)
      .reduce((sum, verbData) => sum + verbData.files.length, 0);
    
    return {
      totalVerbs: navIndex.verbs.length,
      verbsWithData: navIndex.verbs,
      totalFiles
    };
  }

  /**
   * Filter verbs by language level
   */
  async getVerbsByLevel(levelFilter: string): Promise<string[]> {
    const navIndex = await this.loadNavigationIndex();
    
    if (levelFilter === 'All') {
      return navIndex.verbs;
    }
    
    // For now, return all verbs since the navigation index doesn't have level info
    // TODO: Add language level filtering when training examples include level metadata
    console.log(`Language level filtering for "${levelFilter}" not yet implemented`);
    return navIndex.verbs;
  }

  /**
   * Get pagination info
   */
  async getPaginationInfo(verbsPerPage: number = 10): Promise<{
    totalVerbs: number;
    totalPages: number;
    verbsPerPage: number;
  }> {
    const verbs = await this.getAvailableVerbs();
    return {
      totalVerbs: verbs.length,
      totalPages: Math.ceil(verbs.length / verbsPerPage),
      verbsPerPage
    };
  }

  /**
   * Get verb by page and position
   */
  async getVerbByPage(page: number, verbsPerPage: number = 10): Promise<string | null> {
    const verbs = await this.getAvailableVerbs();
    const startIndex = (page - 1) * verbsPerPage;
    
    if (startIndex >= 0 && startIndex < verbs.length) {
      return verbs[startIndex];
    }
    
    return null;
  }

  /**
   * Get current page for a verb
   */
  async getCurrentPage(verb: string, verbsPerPage: number = 10): Promise<number> {
    const verbs = await this.getAvailableVerbs();
    const verbIndex = verbs.indexOf(verb);
    
    if (verbIndex === -1) return 1;
    
    return Math.floor(verbIndex / verbsPerPage) + 1;
  }

  /**
   * Clear cache (useful for development)
   */
  clearCache(): void {
    this.cache.clear();
    this.navigationIndex = null;
    console.log('Cache cleared');
  }
}

// Export singleton instance
export const dataLoader = new DataLoader();