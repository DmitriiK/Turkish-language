import { TrainingExample } from '@/types';

/**
 * Data loading utilities for Turkish verb training examples
 * Uses the navigation index generated by Python script to ensure reliable file paths
 */

interface TenseLevelMapping {
  [tense: string]: string;
}

interface NavigationIndex {
  verbs: string[];
  verb_data: Record<string, {
    english_name: string;
    turkish_infinitive: string;
    folder_name: string;
    tenses: Record<string, {
      tense: string;
      language_levels: string[];
      polarities: {
        positive: {
          pronouns: string[];
          files: Array<{
            pronoun: string;
            polarity: string;
            language_level: string;
            file_path: string;
            relative_path: string;
          }>;
        };
        negative: {
          pronouns: string[];
          files: Array<{
            pronoun: string;
            polarity: string;
            language_level: string;
            file_path: string;
            relative_path: string;
          }>;
        };
      };
    }>;
    files: Array<{
      pronoun: string;
      tense: string;
      polarity: string;
      infinitive: string;
      file_path: string;
      relative_path: string;
      rank: number;
    }>;
  }>;
}

class DataLoader {
  private cache = new Map<string, TrainingExample>();
  private navigationIndex: NavigationIndex | null = null;
  private tenseLevelMapping: TenseLevelMapping | null = null;

  /**
   * Load tense-to-level mapping from the JSON file
   */
  async loadTenseLevelMapping(): Promise<TenseLevelMapping> {
    if (this.tenseLevelMapping) {
      return this.tenseLevelMapping;
    }

    try {
      const response = await fetch('/data/tense_level_mapping.json');
      if (!response.ok) {
        throw new Error(`Failed to load tense level mapping: ${response.status} ${response.statusText}`);
      }
      
      this.tenseLevelMapping = await response.json();
      console.log('Tense level mapping loaded successfully');
      
      return this.tenseLevelMapping!;
    } catch (error) {
      console.error('Error loading tense level mapping:', error);
      throw new Error('Failed to load tense level mapping data.');
    }
  }

  /**
   * Get the language level for a specific tense (polarity doesn't affect level)
   */
  async getLanguageLevelForTense(tense: string): Promise<string | null> {
    const mapping = await this.loadTenseLevelMapping();
    return mapping[tense] || null;
  }

  /**
   * Load navigation index from the JSON file generated by Python script
   */
  async loadNavigationIndex(): Promise<NavigationIndex> {
    if (this.navigationIndex) {
      return this.navigationIndex;
    }

    try {
      console.log('Loading navigation index...');
      const response = await fetch('/data/navigation_index.json');
      if (!response.ok) {
        throw new Error(`Failed to load navigation index: ${response.status} ${response.statusText}`);
      }
      
      this.navigationIndex = await response.json();
      console.log('Navigation index loaded successfully:', {
        totalVerbs: this.navigationIndex!.verbs.length,
        verbSample: this.navigationIndex!.verbs.slice(0, 3)
      });
      
      return this.navigationIndex!;
    } catch (error) {
      console.error('Error loading navigation index:', error);
      throw new Error('Failed to load navigation data. Please ensure the navigation index has been generated.');
    }
  }

  /**
   * Load a training example using exact file path from navigation index
   * If requested pronoun/tense/polarity isn't available, falls back to first available combination
   */
  async loadTrainingExample(
    verbEnglish: string, 
    pronoun: string, 
    tense: string,
    polarity: 'positive' | 'negative' = 'positive'
  ): Promise<TrainingExample | null> {
    try {
      // Load navigation index if not already loaded
      const navIndex = await this.loadNavigationIndex();
      
      // Find verb data
      const verbData = navIndex.verb_data[verbEnglish];
      if (!verbData) {
        console.warn(`Verb "${verbEnglish}" not found in navigation index`);
        return null;
      }

      // If no files available at all, return null
      if (!verbData.files || verbData.files.length === 0) {
        console.warn(`No training examples available for verb "${verbEnglish}"`);
        return null;
      }

      let fileInfo = null;
      let actualTense = tense;
      let actualPronoun = pronoun;
      let actualPolarity = polarity;

      // Try to find exact match first
      const tenseData = verbData.tenses[tense];
      if (tenseData && tenseData.polarities[polarity]) {
        const polarityData = tenseData.polarities[polarity];
        fileInfo = polarityData.files.find(f => f.pronoun === pronoun);
        if (fileInfo) {
          console.log(`✓ Exact match found: ${verbEnglish} - ${tense} (${pronoun}, ${polarity})`);
        }
      }

      // If no exact match, try to find same tense+polarity but different pronoun
      if (!fileInfo && tenseData && tenseData.polarities[polarity]?.files.length > 0) {
        const polarityData = tenseData.polarities[polarity];
        fileInfo = polarityData.files[0];
        actualPronoun = fileInfo.pronoun;
        console.log(`⚠ Pronoun "${pronoun}" not available, using first available: "${actualPronoun}"`);
      }

      // If still no match, try same tense but opposite polarity
      if (!fileInfo && tenseData) {
        const oppositePolarity = polarity === 'positive' ? 'negative' : 'positive';
        const oppositePolarityData = tenseData.polarities[oppositePolarity];
        if (oppositePolarityData && oppositePolarityData.files.length > 0) {
          const match = oppositePolarityData.files.find(f => f.pronoun === pronoun);
          if (match) {
            fileInfo = match;
            actualPronoun = pronoun;
            actualPolarity = oppositePolarity;
            console.log(`⚠ Polarity "${polarity}" not available, using opposite: "${actualPolarity}"`);
          }
        }
      }

      // If still no match, try to find same pronoun but different tense
      if (!fileInfo) {
        for (const [tName, tData] of Object.entries(verbData.tenses)) {
          const polarityData = tData.polarities[polarity];
          if (polarityData) {
            const match = polarityData.files.find(f => f.pronoun === pronoun);
            if (match) {
              fileInfo = match;
              actualPronoun = pronoun;
              actualTense = tName;
              actualPolarity = polarity;
              console.log(`⚠ Tense "${tense}" not available, using: "${actualTense}"`);
              break;
            }
          }
        }
      }

      // If still no match, just use the first available file for this verb
      if (!fileInfo && verbData.files.length > 0) {
        const firstFile = verbData.files[0];
        actualTense = firstFile.tense;
        actualPronoun = firstFile.pronoun;
        actualPolarity = (firstFile.polarity as 'positive' | 'negative') || 'positive';
        // Find the fileInfo from tenses structure
        const firstTenseData = verbData.tenses[actualTense];
        if (firstTenseData && firstTenseData.polarities[actualPolarity]) {
          fileInfo = firstTenseData.polarities[actualPolarity].files.find(f => f.pronoun === actualPronoun);
        }
        console.log(`⚠ Requested combination not available, using first available: ${actualTense} (${actualPronoun}, ${actualPolarity})`);
      }

      if (!fileInfo) {
        console.warn(`No file info found for verb "${verbEnglish}"`);
        return null;
      }

      // Create cache key with actual values
      const cacheKey = `${verbEnglish}-${actualPronoun}-${actualTense}-${actualPolarity}`;
      
      if (this.cache.has(cacheKey)) {
        console.log(`Cache hit for: ${cacheKey}`);
        return this.cache.get(cacheKey)!;
      }

      const filePath = `/${fileInfo.file_path}`;
      console.log(`Loading from path: ${filePath}`);
      
      try {
        const response = await fetch(filePath);
        if (!response.ok) {
          console.warn(`Failed to load: ${filePath} (${response.status}: ${response.statusText})`);
          return null;
        }

        const data: TrainingExample = await response.json();
        
        // Validate that we have the required data
        if (!data.turkish_verb || !data.verb_english) {
          console.warn(`Invalid training example data in ${filePath}`);
          return null;
        }
        
        console.log(`✅ Successfully loaded: ${data.verb_english} - ${data.turkish_verb.verb_tense} (${actualPronoun}, ${actualPolarity})`);
        
        // Cache the result
        this.cache.set(cacheKey, data);
        
        return data;
        
      } catch (fetchError) {
        console.warn(`Network error loading ${filePath}:`, fetchError);
        return null;
      }
    } catch (error) {
      console.error('Error loading training example:', error);
      return null;
    }
  }

  /**
   * Get all available verbs from navigation index
   */
  async getAvailableVerbs(): Promise<string[]> {
    const navIndex = await this.loadNavigationIndex();
    console.log('Available verbs from navigation index:', navIndex.verbs);
    return navIndex.verbs;
  }

  /**
   * Get all available verbs with their ranks
   * Extracts actual verb_rank from training example files in navigation index
   */
  async getVerbsWithRanks(): Promise<Array<{ verb: string; rank: number; turkishInfinitive: string }>> {
    const navIndex = await this.loadNavigationIndex();
    const verbRanks = new Map<string, { rank: number; turkishInfinitive: string }>();
    
    // Extract verb ranks from navigation index files
    // Use the first valid (non-zero, non-null) rank found for each verb
    for (const [verbEnglish, verbData] of Object.entries(navIndex.verb_data)) {
      const ranks = verbData.files
        .map(f => f.rank)
        .filter(r => r && r > 0); // Filter out null, undefined, and 0
      
      if (ranks.length > 0) {
        // Use the minimum rank (most common)
        const minRank = Math.min(...ranks);
        verbRanks.set(verbEnglish, { 
          rank: minRank, 
          turkishInfinitive: verbData.turkish_infinitive 
        });
      }
    }
    
    // Convert to array and sort by rank
    const verbsWithRanks = Array.from(verbRanks.entries())
      .map(([verb, data]) => ({ 
        verb, 
        rank: data.rank, 
        turkishInfinitive: data.turkishInfinitive 
      }))
      .sort((a, b) => a.rank - b.rank);
    
    console.log('Verbs with ranks (sorted by rank):', verbsWithRanks.slice(0, 5));
    
    return verbsWithRanks;
  }

  /**
   * Get available tenses for a specific verb, optionally filtered by language level
   */
  async getAvailableTenses(verbEnglish: string, languageLevel?: string): Promise<string[]> {
    const navIndex = await this.loadNavigationIndex();
    const verbData = navIndex.verb_data[verbEnglish];
    
    if (!verbData) {
      console.warn(`Verb "${verbEnglish}" not found in navigation index`);
      return [];
    }
    
    let tenses = Object.keys(verbData.tenses);
    
    // Filter by language level if specified and not "All"
    if (languageLevel && languageLevel !== 'All') {
      const tenseLevelMapping = await this.loadTenseLevelMapping();
      
      tenses = tenses.filter(tenseName => {
        const tenseLevel = tenseLevelMapping[tenseName];
        
        if (!tenseLevel) return false; // If tense not in mapping, exclude it
        
        // Match exact level (e.g., "A1")
        if (tenseLevel === languageLevel) return true;
        
        // Check if the requested level is a composite that includes this tense's level
        // e.g., if user selects "A1-A2", show both A1 and A2 tenses
        if (languageLevel.includes('-')) {
          const [start, end] = languageLevel.split('-');
          return tenseLevel === start || tenseLevel === end;
        }
        
        return false;
      });
    }
    
    console.log(`Available tenses for "${verbEnglish}"${languageLevel ? ` (level: ${languageLevel})` : ''}:`, tenses);
    return tenses;
  }

  /**
   * Get Turkish infinitive for a verb
   */
  async getTurkishInfinitive(verbEnglish: string): Promise<string | null> {
    const navIndex = await this.loadNavigationIndex();
    const verbData = navIndex.verb_data[verbEnglish];
    
    if (!verbData) {
      console.warn(`Verb "${verbEnglish}" not found in navigation index`);
      return null;
    }
    
    return verbData.turkish_infinitive;
  }

  /**
   * Get available pronouns for a specific verb and tense
   */
  async getAvailablePronouns(verbEnglish: string, tense: string, polarity: 'positive' | 'negative' = 'positive'): Promise<string[]> {
    const navIndex = await this.loadNavigationIndex();
    const verbData = navIndex.verb_data[verbEnglish];
    
    if (!verbData) {
      console.warn(`Verb "${verbEnglish}" not found in navigation index`);
      return [];
    }
    
    // Get tense data
    const tenseData = verbData.tenses[tense];
    if (!tenseData) {
      console.warn(`Tense "${tense}" not found for verb "${verbEnglish}"`);
      return [];
    }
    
    // Get pronouns for the requested polarity
    const polarityData = tenseData.polarities[polarity];
    if (!polarityData) {
      console.warn(`Polarity "${polarity}" not found for verb "${verbEnglish}" in tense "${tense}"`);
      // Try opposite polarity as fallback
      const oppPolarity = polarity === 'positive' ? 'negative' : 'positive';
      const oppPolarityData = tenseData.polarities[oppPolarity];
      if (oppPolarityData) {
        console.log(`Using opposite polarity pronouns for "${verbEnglish}" in "${tense}" (${oppPolarity}):`, oppPolarityData.pronouns);
        return oppPolarityData.pronouns;
      }
      return [];
    }
    
    console.log(`Available pronouns for "${verbEnglish}" in "${tense}" (${polarity}):`, polarityData.pronouns);
    return polarityData.pronouns;
  }



  /**
   * Get next verb in sequence
   */
  async getNextVerb(currentVerb: string): Promise<string | null> {
    const availableVerbs = await this.getAvailableVerbs();
    const currentIndex = availableVerbs.indexOf(currentVerb);
    
    if (currentIndex === -1) {
      console.log('Current verb not found, returning first verb:', availableVerbs[0]);
      return availableVerbs[0]; // Return first verb if current not found
    }
    
    if (currentIndex >= availableVerbs.length - 1) {
      console.log('At end of list, looping back to first verb:', availableVerbs[0]);
      return availableVerbs[0]; // Loop back to first verb
    }
    
    const nextVerb = availableVerbs[currentIndex + 1];
    console.log('Next verb:', nextVerb);
    return nextVerb;
  }

  /**
   * Get previous verb in sequence
   */
  async getPrevVerb(currentVerb: string): Promise<string | null> {
    const availableVerbs = await this.getAvailableVerbs();
    const currentIndex = availableVerbs.indexOf(currentVerb);
    
    if (currentIndex === -1) {
      console.log('Current verb not found, returning last verb:', availableVerbs[availableVerbs.length - 1]);
      return availableVerbs[availableVerbs.length - 1];
    }
    
    if (currentIndex <= 0) {
      console.log('At beginning of list, looping back to last verb:', availableVerbs[availableVerbs.length - 1]);
      return availableVerbs[availableVerbs.length - 1];
    }
    
    const prevVerb = availableVerbs[currentIndex - 1];
    console.log('Previous verb:', prevVerb);
    return prevVerb;
  }

  /**
   * Get next tense for current verb, optionally filtered by language level
   */
  async getNextTense(verbEnglish: string, currentTense: string, languageLevel?: string): Promise<string | null> {
    const tenses = await this.getAvailableTenses(verbEnglish, languageLevel);
    const currentIndex = tenses.indexOf(currentTense);
    
    if (currentIndex === -1) {
      console.log(`Tense "${currentTense}" not found, returning first tense:`, tenses[0]);
      return tenses[0]; // Return first tense if current not found
    }
    
    if (currentIndex >= tenses.length - 1) {
      console.log('At end of tense list, looping back to first tense:', tenses[0]);
      return tenses[0]; // Loop back to first tense
    }
    
    const nextTense = tenses[currentIndex + 1];
    console.log('Next tense:', nextTense);
    return nextTense;
  }

  /**
   * Get previous tense for current verb, optionally filtered by language level
   */
  async getPrevTense(verbEnglish: string, currentTense: string, languageLevel?: string): Promise<string | null> {
    const tenses = await this.getAvailableTenses(verbEnglish, languageLevel);
    const currentIndex = tenses.indexOf(currentTense);
    
    if (currentIndex === -1) {
      console.log(`Tense "${currentTense}" not found, returning last tense:`, tenses[tenses.length - 1]);
      return tenses[tenses.length - 1];
    }
    
    if (currentIndex <= 0) {
      console.log('At beginning of tense list, looping back to last tense:', tenses[tenses.length - 1]);
      return tenses[tenses.length - 1];
    }
    
    const prevTense = tenses[currentIndex - 1];
    console.log('Previous tense:', prevTense);
    return prevTense;
  }

  /**
   * Get next pronoun for current verb/tense
   */
  async getNextPronoun(verbEnglish: string, tense: string, currentPronoun: string, polarity: 'positive' | 'negative' = 'positive'): Promise<string | null> {
    const pronouns = await this.getAvailablePronouns(verbEnglish, tense, polarity);
    const currentIndex = pronouns.indexOf(currentPronoun);
    
    if (currentIndex === -1) {
      console.log(`Pronoun "${currentPronoun}" not found, returning first pronoun:`, pronouns[0]);
      return pronouns[0]; // Return first pronoun if current not found
    }
    
    if (currentIndex >= pronouns.length - 1) {
      console.log('At end of pronoun list, looping back to first pronoun:', pronouns[0]);
      return pronouns[0]; // Loop back to first pronoun
    }
    
    const nextPronoun = pronouns[currentIndex + 1];
    console.log('Next pronoun:', nextPronoun);
    return nextPronoun;
  }

  /**
   * Get previous pronoun for current verb/tense
   */
  async getPrevPronoun(verbEnglish: string, tense: string, currentPronoun: string, polarity: 'positive' | 'negative' = 'positive'): Promise<string | null> {
    const pronouns = await this.getAvailablePronouns(verbEnglish, tense, polarity);
    const currentIndex = pronouns.indexOf(currentPronoun);
    
    if (currentIndex === -1) {
      console.log(`Pronoun "${currentPronoun}" not found, returning last pronoun:`, pronouns[pronouns.length - 1]);
      return pronouns[pronouns.length - 1];
    }
    
    if (currentIndex <= 0) {
      console.log('At beginning of pronoun list, looping back to last pronoun:', pronouns[pronouns.length - 1]);
      return pronouns[pronouns.length - 1];
    }
    
    const prevPronoun = pronouns[currentIndex - 1];
    console.log('Previous pronoun:', prevPronoun);
    return prevPronoun;
  }

  /**
   * Get verb by index (for rank-like functionality)
   */
  async getVerbByIndex(index: number): Promise<string | null> {
    const availableVerbs = await this.getAvailableVerbs();
    if (index >= 0 && index < availableVerbs.length) {
      return availableVerbs[index];
    }
    return null;
  }

  /**
   * Get random training example for quick start
   */
  async getRandomExample(): Promise<TrainingExample | null> {
    try {
      const verbs = await this.getAvailableVerbs();
      if (verbs.length === 0) return null;
      
      const randomVerb = verbs[Math.floor(Math.random() * verbs.length)];
      const tenses = await this.getAvailableTenses(randomVerb);
      if (tenses.length === 0) return null;
      
      const randomTense = tenses[Math.floor(Math.random() * tenses.length)];
      const pronouns = await this.getAvailablePronouns(randomVerb, randomTense);
      if (pronouns.length === 0) return null;
      
      const randomPronoun = pronouns[Math.floor(Math.random() * pronouns.length)];
      
      return await this.loadTrainingExample(randomVerb, randomPronoun, randomTense);
    } catch (error) {
      console.error('Error getting random example:', error);
      return null;
    }
  }

  /**
   * Get summary statistics from navigation index
   */
  async getStatistics(): Promise<{
    totalVerbs: number;
    verbsWithData: string[];
    totalFiles: number;
  }> {
    const navIndex = await this.loadNavigationIndex();
    const totalFiles = Object.values(navIndex.verb_data)
      .reduce((sum, verbData) => sum + verbData.files.length, 0);
    
    return {
      totalVerbs: navIndex.verbs.length,
      verbsWithData: navIndex.verbs,
      totalFiles
    };
  }

  /**
   * Filter verbs by language level
   */
  async getVerbsByLevel(levelFilter: string): Promise<string[]> {
    const navIndex = await this.loadNavigationIndex();
    
    if (levelFilter === 'All') {
      return navIndex.verbs;
    }
    
    // For now, return all verbs since the navigation index doesn't have level info
    // TODO: Add language level filtering when training examples include level metadata
    console.log(`Language level filtering for "${levelFilter}" not yet implemented`);
    return navIndex.verbs;
  }

  /**
   * Get pagination info
   */
  async getPaginationInfo(verbsPerPage: number = 10): Promise<{
    totalVerbs: number;
    totalPages: number;
    verbsPerPage: number;
  }> {
    const verbs = await this.getAvailableVerbs();
    return {
      totalVerbs: verbs.length,
      totalPages: Math.ceil(verbs.length / verbsPerPage),
      verbsPerPage
    };
  }

  /**
   * Get verb by page and position
   */
  async getVerbByPage(page: number, verbsPerPage: number = 10): Promise<string | null> {
    const verbs = await this.getAvailableVerbs();
    const startIndex = (page - 1) * verbsPerPage;
    
    if (startIndex >= 0 && startIndex < verbs.length) {
      return verbs[startIndex];
    }
    
    return null;
  }

  /**
   * Get current page for a verb
   */
  async getCurrentPage(verb: string, verbsPerPage: number = 10): Promise<number> {
    const verbs = await this.getAvailableVerbs();
    const verbIndex = verbs.indexOf(verb);
    
    if (verbIndex === -1) return 1;
    
    return Math.floor(verbIndex / verbsPerPage) + 1;
  }

  /**
   * Clear cache (useful for development)
   */
  clearCache(): void {
    this.cache.clear();
    this.navigationIndex = null;
    console.log('Cache cleared');
  }
}

// Export singleton instance
export const dataLoader = new DataLoader();